/*
 * z_touch_XPT2046_test.c
 *
 *  Created on: 2 giu 2022
 *      Author: mauro
 *
 *  This is related to the functions testing features and showing performance
 *  you don't need this file in the production project
 *
 *  licensing: https://github.com/maudeve-it/ILI9XXX-XPT2046-STM32/blob/c097f0e7d569845c1cf98e8d930f2224e427fd54/LICENSE
 *
 *  Do you want to test functions?
 *  follow STEP_1 in z_displ_ILI9488_test.c
 *  then:
 *
 *  STEP_2
 *	in the main loop remove or comment previous command and put:
 *	Touch_ShowData();					// shows data returned by XPT2046 controller: try touching everywhere the display
 *
 *  STEP_3
 *	in the main loop remove or comment previous command and put:
 *	Touch_TestCalibration();			// compute and shows parameters to adopt converting XPT2046 data into display coordinates.
 *		 								// compare the (green) data shown with data in z_touch_XPT2046.h and, in case of needs, change it.
 *
 *  STEP_4
 *	in the main loop remove or comment previous command and put:
 *	Touch_TestDrawing();				//move pen on display while touching to check quality of parameters detected on step 3
 *										// repeat test on 4 display orientation
 *
 */


#include "main.h"
#include <stdint.h> // To ensure uint8_t is recognized
#include "string.h"
extern int16_t _width;       								///< (oriented) display width
extern int16_t _height;      								///< (oriented) display height
extern uint8_t txData;
char num[10];
uint16_t selectedColor = RED;  // กำหนดสีเริ่มต้น
uint8_t cursorSize = 5;             // กำหนดขนาดเคอร์เซอร์เริ่มต้น
uint16_t backgroundColor = BLACK;

// ขนาดของปุ่มเมนู
#define MENU_BUTTON_WIDTH 40
#define MENU_BUTTON_HEIGHT 40
extern SPI_HandleTypeDef hspi3;


// พิกัดสำหรับปุ่มเมนูต่าง ๆ บนขอบจอ (สามารถปรับได้)
#define CLEAR_BUTTON_X 10
#define CLEAR_BUTTON_Y 0
#define COLOR_RED_BUTTON_X 60
#define COLOR_RED_BUTTON_Y 0
#define COLOR_GREEN_BUTTON_X 110
#define COLOR_GREEN_BUTTON_Y 0
#define COLOR_BLUE_BUTTON_X 160
#define COLOR_BLUE_BUTTON_Y 0
#define INCREASE_CURSOR_BUTTON_X 210
#define INCREASE_CURSOR_BUTTON_Y 0
#define DECREASE_CURSOR_BUTTON_X 260
#define DECREASE_CURSOR_BUTTON_Y 0


/*Define for number */


// พิกัดของปุ่มตัวเลข 0-9
#define BUTTON_X_START 10
#define BUTTON_Y_START 50
#define BUTTON_X_SPACING 50
#define BUTTON_Y_SPACING 50
#define BUTTON_WIDTH 40
#define BUTTON_HEIGHT 40

#define MAX_TEXT_LENGTH 21     // ความยาวสูงสุดของข้อความในกล่องข้อความ


char displayText[MAX_TEXT_LENGTH] = "";  // ตัวแปรเก็บข้อความที่กด

/*end of define number Draw*/
/*************************************************************
 * used by Touch_TestDrawing() and Touch_TestCalibration()
 *************************************************************/
void DrawCross(uint16_t x,uint16_t y,uint16_t fcol){
	uint8_t ray=10;
	//	Displ_Line(x-ray, y-ray, x+ray, y+ray, fcol);
	//	Displ_Line(x-ray, y+ray, x+ray, y-ray, fcol);
	Displ_Line(x-ray, y, x+ray, y, fcol);
	Displ_Line(x, y-ray, x, y+ray, fcol);

}

/*************************************************************
 * used by Touch_TestDrawing() and Touch_TestCalibration()
 *************************************************************/
void MoveCross(uint16_t x1,uint16_t y1,uint16_t x2,uint16_t y2,uint16_t fcol,uint16_t bcol){
	const uint8_t steps=20;
	int16_t deltax,deltay;

	deltax = (x2-x1)/steps;
	deltay = (y2-y1)/steps;

	while ((x1!=x2) || (y1!=y2)) {
		DrawCross(x1,y1,bcol);

		x1=((abs((x2-x1))>abs(deltax)) ? (x1+deltax) : x2);
		y1=((abs((y2-y1))>abs(deltay)) ? (y1+deltay) : y2);

		DrawCross(x1,y1,fcol);
		HAL_Delay(500/steps);
	}
}

extern uint16_t Touch_PollAxis(uint8_t axis);

/*****************************************************
 * polls the 3 axis of touch device and shows values returned
 *****************************************************/
void Touch_ShowData(void)
{
	uint16_t x_touch;
	uint16_t y_touch;
	uint16_t z_touch;
	char text[30];
	uint32_t touchTime=0,touchDelay;

	Displ_Orientation(Displ_Orientat_270);

	Displ_FillArea(0,0,_width,_height,WHITE);

	while (1) {

		if (Touch_GotATouch(1))
			touchTime=HAL_GetTick();
		touchDelay=(HAL_GetTick() - touchTime);

		z_touch = Touch_PollAxis(Z_AXIS);
		x_touch = Touch_PollAxis(X_AXIS);
		y_touch = Touch_PollAxis(Y_AXIS);

		if ((touchDelay<100) && (touchTime!=0)) {
			strcpy(text,"PENDOWN");
			Displ_WString(10,30,text,Font20,1,RED,YELLOW);
		};
		if (touchDelay>=100) {
			strcpy(text,"       ");
			Displ_WString(10,30,text,Font20,1,BLUE,WHITE);
			touchDelay=0;
		};


		sprintf(text,"X=%#X -         ",x_touch);
		Displ_WString(10,60,text,Font20,1,BLUE,WHITE);
		sprintf(text,"Y=%#X -         ",y_touch);
		Displ_WString(10,80,text,Font20,1,BLUE,WHITE);
		sprintf(text,"Z=%#X -         ",z_touch);
		Displ_WString(10,100,text,Font20,1,BLUE,WHITE);

		// แสดงตำแหน่งสัมผัส X, Y ในตำแหน่งที่ต่างออกไป
		sprintf(text, "Pos X:%d Y:%d", x_touch, y_touch);
		Displ_WString(10, 120, text, Font20, 1, GREEN, WHITE);
		HAL_Delay(100);
	}

}

/****************************************
 * a test with a continue touch polling,
 * drawing values returned,
 * until touch is released
 ****************************************/
void Touch_TestDrawing() {
	uint16_t px=0,py,npx,npy;
	uint8_t isTouch;

	for (uint8_t k=0;k<4;k++){

		switch (k){
		case 0:
			Displ_Orientation(Displ_Orientat_0);
			break;
		case 1:
			Displ_Orientation(Displ_Orientat_90);
			break;
		case 2:
			Displ_Orientation(Displ_Orientat_180);
			break;
		case 3:
			Displ_Orientation(Displ_Orientat_270);
			break;
		}

		Displ_CLS(DD_BLUE);
		Displ_CString(0,10,_width,Font12.Height+10,"Touch and drag over display",Font12,1,WHITE,DD_BLUE);

		Touch_GotATouch(1);
		Touch_WaitForTouch(0);

		while (1) {
			Touch_GetXYtouch(&npx,&npy,&isTouch);
			if (!isTouch) //if there is no touch: stop drawing
				break;
			if (px!=0)
				DrawCross(px,py,DD_BLUE);
			DrawCross(npx,npy,WHITE);
			px=npx;
			py=npy;
			HAL_Delay(30);
		}
	}
}

void Touch_TestCalibration(){
	uint8_t correct_orientation=0;
	Displ_Orientat_e orientation=Displ_Orientat_0;

#ifdef ILI9488
	const uint16_t shift=80;
#endif
#ifdef ILI9341
	const uint16_t shift=50;
#endif
	char text[30];
	uint16_t x[5];
	uint16_t y[5];
	uint32_t read_x[5]={0,0,0,0,0};
	uint32_t read_y[5]={0,0,0,0,0};
	uint32_t r_x,r_y,r_z;
	uint32_t xx,yy;
	uint8_t k,h;
	float ax[2];
	float bx[2];
	float ay[2];
	float by[2];
	float axx,bxx,ayy,byy,e;
	//	uint8_t orientation;
	sFONT font;

	while (! correct_orientation) {
		Displ_CLS(WHITE);
		Displ_Orientation(orientation);
		//setting positions for calibration
		x[0]=shift;
		x[1]=_width-shift;
		x[2]=shift;
		x[3]=_width-shift;
		x[4]=_width>>1;
		y[0]=shift;
		y[1]=_height-shift;
		y[2]=_height-shift;
		y[3]=shift;
		y[4]=_height>>1;
		for (uint8_t k=0; k<2; k++) {
			switch (k) {
			case 0:
				strcpy(text,"Press and briefly hold");
				break;
			case 1:
				strcpy(text,"stylus on the target.");
				break;
			}
			Displ_CString(0,10+Font12.Height*k,_width,10+Font12.Height*(1+k),text,Font12,1,BLACK,WHITE);

		}
		for (uint8_t k=0; k<2; k++) {
			switch (k) {
			case 0:
				strcpy(text,"Repeat as the target");
				break;
			case 1:
				strcpy(text,"moves around the screen.");
				break;
			}
			Displ_CString(0,_height+Font12.Height*(k-2)-10,_width,_height+Font12.Height*(k-1)-10,text,Font12,1,BLACK,WHITE);

		}

		HAL_Delay(1000);
		Touch_WaitForUntouch(0);

		for (h=0;h<5;h++){    // 5 point calibration
			DrawCross(x[h],y[h],BLACK);
			// wait for stylus
			Touch_WaitForTouch(0);

			// makes NUM_READINGS touch polling calculating average value
			k=0;
			while (k<NUM_READINGS) {
				r_x=Touch_PollAxis(X_AXIS);
				r_y=Touch_PollAxis(Y_AXIS);
				r_z=Touch_PollAxis(Z_AXIS);
				if ((r_z>Z_THRESHOLD) && (r_x>X_THRESHOLD)) {
					read_x[h]+=r_x;
					read_y[h]+=r_y;
					k++;
					HAL_Delay(10);
				}

			}
			read_x[h]=read_x[h]/NUM_READINGS;
			read_y[h]=read_y[h]/NUM_READINGS;

			if (h!=4)
				MoveCross(x[h],y[h],x[h+1],y[h+1],BLACK,WHITE);

			// wait for user removing stylus
			Touch_WaitForUntouch(0);
		}

		//check il display and touch_sensor orientation are aligned

		correct_orientation=1;
		correct_orientation &= (read_x[1]>read_x[0]);
		correct_orientation &= (read_y[1]>read_y[0]);
		correct_orientation &= (read_x[2]<read_x[1]);
		correct_orientation &= (read_x[3]>read_x[2]);
		correct_orientation &= (read_y[3]<read_y[2]);
		correct_orientation &= (read_x[4]<read_x[3]);
		correct_orientation &= (read_y[4]>read_y[3]);

		if (! correct_orientation){   //they could be alighen but inverted x axes
			correct_orientation=1;
			correct_orientation &= (read_x[1]<read_x[0]);
			correct_orientation &= (read_y[1]>read_y[0]);
			correct_orientation &= (read_x[2]>read_x[1]);
			correct_orientation &= (read_x[3]<read_x[2]);
			correct_orientation &= (read_y[3]<read_y[2]);
			correct_orientation &= (read_x[4]>read_x[3]);
			correct_orientation &= (read_y[4]>read_y[3]);
		}

		if (! correct_orientation){  // if not aligned, rotate display
			Displ_CLS(WHITE);
			Displ_CString(0,((_height>>1)-31),_width,((_height>>1)-10),"please",Font20,1,BLUE,WHITE);
			Displ_CString(0,((_height>>1)-11),_width,((_height>>1)+10),"repeat",Font20,1,BLUE,WHITE);
			Displ_CString(0,((_height>>1)+11),_width,((_height>>1)+20),"calibration",Font20,1,BLUE,WHITE);
			HAL_Delay(2000);
			switch (orientation) {
			case Displ_Orientat_0:
				orientation=Displ_Orientat_90;
				break;
			case Displ_Orientat_90:
				orientation=Displ_Orientat_180;
				break;
			case Displ_Orientat_180:
				orientation=Displ_Orientat_270;
				break;
			case Displ_Orientat_270:
				orientation=Displ_Orientat_0;
				break;

			}

		}

	}

	//calculate linear conversion parameter between point 1 and 2

	ax[0]=(x[0]+0.0f)-x[1];
	bx[0]=((x[1]+0.0f)*read_x[0])-((x[0]+0.0f)*read_x[1]);
	e=((read_x[0]+0.0f)-read_x[1]);
	ax[0]=ax[0]/e;
	bx[0]=bx[0]/e;

	ay[0]=(y[0]+0.0f)-y[1];
	by[0]=((y[1]+0.0f)*read_y[0])-((y[0]+0.0f)*read_y[1]);
	ay[0]=ay[0]/((read_y[0]+0.0f)-read_y[1]);
	by[0]=by[0]/((read_y[0]+0.0f)-read_y[1]);

	//calculate linear conversion parameter between point 3 and 4
	ax[1]=(x[2]+0.0f)-x[3];
	bx[1]=((x[3]+0.0f)*read_x[2])-((x[2]+0.0f)*read_x[3]);
	e=((read_x[2]+0.0f)-read_x[3]);
	ax[1]=ax[1]/e;
	bx[1]=bx[1]/e;

	ay[1]=(y[2]+0.0f)-y[3];
	by[1]=((y[3]+0.0f)*read_y[2])-((y[2]+0.0f)*read_y[3]);
	ay[1]=ay[1]/((read_y[2]+0.0f)-read_y[3]);
	by[1]=by[1]/((read_y[2]+0.0f)-read_y[3]);


	// calculate average conversion parameters

	axx = (ax[0] + ax[1])/2;
	bxx = (bx[0] + bx[1])/2;
	ayy = (ay[0] + ay[1])/2;
	byy = (by[0] + by[1])/2;


	Displ_CLS(WHITE);

#ifdef ILI9488
	font=Font16;
#endif
#ifdef ILI9341
	font=Font12;
#endif

	k=1;
	sprintf(text,"Current config:");
	Displ_WString(10,10+Font12.Height*k++,text,font,1,BLACK,WHITE);
	sprintf(text,"Ax=%f Bx=%f",AX,BX);
	Displ_WString(10,10+Font12.Height*k++,text,font,1,BLACK,WHITE);
	sprintf(text,"Ay=%f By=%f",AY,BY);
	Displ_WString(10,10+Font12.Height*k++,text,font,1,BLACK,WHITE);
#ifdef  T_ROTATION_0
	sprintf(text,"Orientation 0");
#endif
#ifdef  T_ROTATION_90
	sprintf(text,"Orientation 90");
#endif
#ifdef  T_ROTATION_180
	sprintf(text,"Orientation 180");
#endif
#ifdef  T_ROTATION_270
	sprintf(text,"Orientation 270");
#endif
	Displ_WString(10,10+Font12.Height*k++,text,font,1,BLACK,WHITE);
	k++;
	sprintf(text,"Current test:");
	Displ_WString(10,10+font.Height*k++,text,font,1,BLACK,WHITE);
	sprintf(text,"Ax=%f Bx=%f",ax[0],bx[0]);
	Displ_WString(10,10+font.Height*k++,text,font,1,RED,WHITE);
	sprintf(text,"Ay=%f By=%f",ay[0],by[0]);
	Displ_WString(10,10+font.Height*k++,text,font,1,RED,WHITE);
	sprintf(text,"Ax=%f Bx=%f",ax[1],bx[1]);
	Displ_WString(10,10+font.Height*k++,text,font,1,BLUE,WHITE);
	sprintf(text,"Ay=%f By=%f",ay[1],by[1]);
	Displ_WString(10,10+font.Height*k++,text,font,1,BLUE,WHITE);
	k++;
	sprintf(text,"Proposed config:");
	Displ_WString(10,10+font.Height*k++,text,font,1,BLACK,WHITE);
	sprintf(text,"Ax=%f Bx=%f",axx,bxx);
	Displ_WString(10,10+font.Height*k++,text,font,1,DD_GREEN,WHITE);
	sprintf(text,"Ay=%f By=%f",ayy,byy);
	Displ_WString(10,10+font.Height*k++,text,font,1,DD_GREEN,WHITE);
	switch (orientation) {
	case 0:
		sprintf(text,"Orientation 0");
		break;
	case 1:
		sprintf(text,"Orientation 270");
		break;
	case 2:
		sprintf(text,"Orientation 180");
		break;
	case 3:
		sprintf(text,"Orientation 90");
	}
	Displ_WString(10,10+font.Height*k++,text,font,1,DD_GREEN,WHITE);

	xx=(ax[0]*read_x[4]+bx[0]);
	yy=(ay[0]*read_y[4]+by[0]);
	DrawCross(xx,yy,RED);
	xx=(ax[1]*read_x[4]+bx[1]);
	yy=(ay[1]*read_y[4]+by[1]);
	DrawCross(xx,yy,BLUE);
	xx=(axx*read_x[4]+bxx);
	yy=(ayy*read_y[4]+byy);
	DrawCross(xx,yy,DD_GREEN);

	Touch_WaitForTouch(0);
}

void Touch_DrawWithColorAndSize(uint16_t x, uint16_t y, uint16_t color, uint8_t size)
{
	// ตรวจสอบว่าตำแหน่งอยู่ภายในขอบเขตหน้าจอ
	if (x < _width && y < _height) {
		// วาดสี่เหลี่ยมที่ตำแหน่ง x, y ด้วยสีและขนาดที่กำหนด
		for (int i = -size / 2; i < size / 2; i++) {
			for (int j = -size / 2; j < size / 2; j++) {
				if ((x + i) < _width && (y + j) < _height) {
					Displ_Pixel(x + i, y + j, color);
				}
			}
		}
	}
}

void Touch_DrawLoop() {
	uint16_t touchX, touchY;
	uint8_t isTouch;

	DrawMenu_init();  // วาดเมนูเมื่อเริ่มต้น

	// ลูปหลักสำหรับการวาด
	while (1) {
		Touch_GetXYtouch(&touchX, &touchY, &isTouch);

		if (isTouch) {
			if (touchY < MENU_BUTTON_HEIGHT) {
				// ถ้าสัมผัสอยู่ในขอบเมนู เรียกฟังก์ชันเช็คปุ่ม
				CheckTouchForMenu(touchX, touchY);
			} else {
				// ถ้าสัมผัสในพื้นที่วาด ให้เรียกวาดตามค่า selectedColor และ cursorSize
				Displ_fillCircle(touchX, touchY, cursorSize, selectedColor);
			}
			HAL_Delay(30);
		}
	}
}

// ฟังก์ชันสำหรับการเปลี่ยนสีที่เลือก
void SetSelectedColor(uint16_t color) {
	selectedColor = color;
}

// ฟังก์ชันสำหรับการเปลี่ยนขนาดเคอร์เซอร์
void SetCursorSize(uint8_t size) {
	if (size > 0) {
		cursorSize = size;
	}
}

// ฟังก์ชันการวาดปุ่ม
void DrawMenu_init() {
	// ปุ่มล้างหน้าจอ
	Displ_fillRoundRect(CLEAR_BUTTON_X, CLEAR_BUTTON_Y, MENU_BUTTON_WIDTH, MENU_BUTTON_HEIGHT, 10, WHITE);
	Displ_CString(CLEAR_BUTTON_X + 5, CLEAR_BUTTON_Y + 10, CLEAR_BUTTON_X + MENU_BUTTON_WIDTH - 5, CLEAR_BUTTON_Y + MENU_BUTTON_HEIGHT - 10, "Clear", Font8, 1, BLACK, WHITE);

	// ปุ่มเลือกสี
	Displ_fillRoundRect(COLOR_RED_BUTTON_X, COLOR_RED_BUTTON_Y, MENU_BUTTON_WIDTH, MENU_BUTTON_HEIGHT, 10, RED);
	Displ_fillRoundRect(COLOR_GREEN_BUTTON_X, COLOR_GREEN_BUTTON_Y, MENU_BUTTON_WIDTH, MENU_BUTTON_HEIGHT, 10, GREEN);
	Displ_fillRoundRect(COLOR_BLUE_BUTTON_X, COLOR_BLUE_BUTTON_Y, MENU_BUTTON_WIDTH, MENU_BUTTON_HEIGHT, 10, BLUE);

	// ปุ่มเพิ่ม/ลดขนาดเคอร์เซอร์
	Displ_fillRoundRect(INCREASE_CURSOR_BUTTON_X, INCREASE_CURSOR_BUTTON_Y, MENU_BUTTON_WIDTH, MENU_BUTTON_HEIGHT, 10, YELLOW);
	Displ_CString(INCREASE_CURSOR_BUTTON_X + 10, INCREASE_CURSOR_BUTTON_Y + 10, INCREASE_CURSOR_BUTTON_X + MENU_BUTTON_WIDTH - 10, INCREASE_CURSOR_BUTTON_Y + MENU_BUTTON_HEIGHT - 10, "+", Font8, 1, BLACK, YELLOW);

	Displ_fillRoundRect(DECREASE_CURSOR_BUTTON_X, DECREASE_CURSOR_BUTTON_Y, MENU_BUTTON_WIDTH, MENU_BUTTON_HEIGHT, 10, CYAN);
	Displ_CString(DECREASE_CURSOR_BUTTON_X + 10, DECREASE_CURSOR_BUTTON_Y + 10, DECREASE_CURSOR_BUTTON_X + MENU_BUTTON_WIDTH - 10, DECREASE_CURSOR_BUTTON_Y + MENU_BUTTON_HEIGHT - 10, "-", Font8, 1, BLACK, CYAN);
}

// ฟังก์ชันล้างหน้าจอ
void ClearScreen() {
	Displ_CLS(backgroundColor); // ล้างหน้าจอด้วยสีพื้นหลังที่กำหนดไว้
	DrawMenu_init(); // วาดเมนูอีกครั้งหลังล้างหน้าจอ
}

// ฟังก์ชันตรวจสอบว่าการสัมผัสอยู่ในปุ่มใด
void CheckTouchForMenu(uint16_t x, uint16_t y) {
	if (x >= CLEAR_BUTTON_X && x < (CLEAR_BUTTON_X + MENU_BUTTON_WIDTH) &&
			y >= CLEAR_BUTTON_Y && y < (CLEAR_BUTTON_Y + MENU_BUTTON_HEIGHT)) {
		ClearScreen();
	} else if (x >= COLOR_RED_BUTTON_X && x < (COLOR_RED_BUTTON_X + MENU_BUTTON_WIDTH) &&
			y >= COLOR_RED_BUTTON_Y && y < (COLOR_RED_BUTTON_Y + MENU_BUTTON_HEIGHT)) {
		selectedColor = RED;
	} else if (x >= COLOR_GREEN_BUTTON_X && x < (COLOR_GREEN_BUTTON_X + MENU_BUTTON_WIDTH) &&
			y >= COLOR_GREEN_BUTTON_Y && y < (COLOR_GREEN_BUTTON_Y + MENU_BUTTON_HEIGHT)) {
		selectedColor = GREEN;
	} else if (x >= COLOR_BLUE_BUTTON_X && x < (COLOR_BLUE_BUTTON_X + MENU_BUTTON_WIDTH) &&
			y >= COLOR_BLUE_BUTTON_Y && y < (COLOR_BLUE_BUTTON_Y + MENU_BUTTON_HEIGHT)) {
		selectedColor = BLUE;
	} else if (x >= INCREASE_CURSOR_BUTTON_X && x < (INCREASE_CURSOR_BUTTON_X + MENU_BUTTON_WIDTH) &&
			y >= INCREASE_CURSOR_BUTTON_Y && y < (INCREASE_CURSOR_BUTTON_Y + MENU_BUTTON_HEIGHT)) {
		cursorSize++;
	} else if (x >= DECREASE_CURSOR_BUTTON_X && x < (DECREASE_CURSOR_BUTTON_X + MENU_BUTTON_WIDTH) &&
			y >= DECREASE_CURSOR_BUTTON_Y && y < (DECREASE_CURSOR_BUTTON_Y + MENU_BUTTON_HEIGHT)) {
		if (cursorSize > 1) cursorSize--;
	}
}


// ฟังก์ชันแสดงปุ่มตัวเลข 0-9
void DrawNumberButtons(void) {
	char num_str[2];
	for (uint8_t i = 0; i < 10; i++) {
		sprintf(num_str, "%d", i);

		Displ_drawRoundRect(BUTTON_X_START + (i % 3) * BUTTON_X_SPACING, BUTTON_Y_START + (i / 3) * BUTTON_Y_SPACING, BUTTON_WIDTH, BUTTON_HEIGHT, 10, BLACK);
		Displ_WString(BUTTON_X_START + (i % 3) * BUTTON_X_SPACING + 10, BUTTON_Y_START + (i / 3) * BUTTON_Y_SPACING + 10, num_str, Font20, 1, BLACK, WHITE);
	}
}
// ฟังก์ชันตรวจจับการสัมผัสและการกดปุ่ม
void CheckButtonPress(uint16_t x_touch, uint16_t y_touch) {
	// ตรวจสอบการกดปุ่ม 0-9
	for (uint8_t i = 0; i < 10; i++) {
		uint16_t button_x = BUTTON_X_START + (i % 3) * BUTTON_X_SPACING;
		uint16_t button_y = BUTTON_Y_START + (i / 3) * BUTTON_Y_SPACING;

		if (x_touch >= button_x && x_touch <= button_x + BUTTON_WIDTH && y_touch >= button_y && y_touch <= button_y + BUTTON_HEIGHT) {
			// ตัวอย่าง: แสดงผลตัวเลขที่กด
			char num_str[2];
			sprintf(num_str, "%d", i);
			Displ_WString(10, 10, num_str, Font20, 1, BLUE, WHITE);

			// strncpy((char*)txData, num_str, sizeof(txData) - 1); // จำกัดขนาดข้อมูลตามขนาดของ txData
			// HAL_SPI_Transmit(&hspi3, txData, strlen((char*)txData), HAL_MAX_DELAY);
		}
	}
}

// ฟังก์ชันแสดงตำแหน่งสัมผัส
void Touch_TestNumberEntry() {
	uint16_t x_touch, y_touch;
	uint8_t isTouch;

	// Displ_CLS(WHITE);
	DrawNumberButtons();  // วาดปุ่มตัวเลข

	while (1) {
		Touch_GetXYtouch(&x_touch, &y_touch, &isTouch);
		if (isTouch) {
			CheckButtonPress(x_touch, y_touch);  // ตรวจจับการกดปุ่ม
		}
		HAL_Delay(100);
	}
}

// ฟังก์ชันแสดงปุ่มตัวอักษร A-Z
void DrawLetterButtons(void) {
	char letter_str[2];
	for (uint8_t i = 0; i < 26; i++) {
		letter_str[0] = 'A' + i;
		letter_str[1] = '\0';

		Displ_drawRoundRect(BUTTON_X_START + (i % 6) * BUTTON_X_SPACING, BUTTON_Y_START + (i / 6) * BUTTON_Y_SPACING, BUTTON_WIDTH, BUTTON_HEIGHT, 10, BLACK);
		Displ_WString(BUTTON_X_START + (i % 6) * BUTTON_X_SPACING + 10, BUTTON_Y_START + (i / 6) * BUTTON_Y_SPACING + 10, letter_str, Font20, 1, BLACK, WHITE);
		// วาดปุ่ม Backspace
		Displ_drawRoundRect(BUTTON_X_START + 5 * BUTTON_X_SPACING, BUTTON_Y_START + 4 * BUTTON_Y_SPACING, BUTTON_WIDTH, BUTTON_HEIGHT, 10, BLACK);
		Displ_WString(BUTTON_X_START + 5 * BUTTON_X_SPACING + 5, BUTTON_Y_START + 4 * BUTTON_Y_SPACING + 10, "Del", Font20, 1, BLACK, WHITE);
	}
}

// ฟังก์ชันแสดงกล่องข้อความ
void DisplayTextBox(void) {
	Displ_fillRoundRect(20, 10, 299, 29, 1, WHITE);
	Displ_drawRoundRect(20, 10, 300, 30, 1, BLACK);
    Displ_WString(25, 15, displayText, Font20, 1, BLACK, WHITE);  // แสดงข้อความใหม่
}

// ฟังก์ชันตรวจจับการสัมผัสและการกดปุ่มตัวอักษร
void CheckLetterButtonPress(uint16_t x_touch, uint16_t y_touch) {
	for (uint8_t i = 0; i < 26; i++) {
		uint16_t button_x = BUTTON_X_START + (i % 6) * BUTTON_X_SPACING;
		uint16_t button_y = BUTTON_Y_START + (i / 6) * BUTTON_Y_SPACING;

		if (x_touch >= button_x && x_touch <= button_x + BUTTON_WIDTH &&
				y_touch >= button_y && y_touch <= button_y + BUTTON_HEIGHT) {
			char letter_str[2];
			letter_str[0] = 'A' + i;
			letter_str[1] = '\0';

			// เพิ่มตัวอักษรที่กดลงใน displayText
			if (strlen(displayText) < MAX_TEXT_LENGTH - 1) {
				strcat(displayText, letter_str);
				DisplayTextBox();  // แสดงกล่องข้อความใหม่
			}

			//ส่งข้อมูลผ่าน SPI ถ้าต้องการ
			//strncpy((char*)txData, letter_str, sizeof(txData) - 1);
			//HAL_SPI_Transmit(&hspi3, txData, strlen((char*)txData), HAL_MAX_DELAY);
			//return;

		}
	}

	// ตรวจสอบการกดปุ่มลบ (Backspace)
	uint16_t backspace_x = BUTTON_X_START + 5 * BUTTON_X_SPACING;
	uint16_t backspace_y = BUTTON_Y_START + 4 * BUTTON_Y_SPACING;
	if (x_touch >= backspace_x && x_touch <= backspace_x + BUTTON_WIDTH &&
			y_touch >= backspace_y && y_touch <= backspace_y + BUTTON_HEIGHT) {

		// ลบตัวอักษรล่าสุดใน displayText
		size_t len = strlen(displayText);
		if (len > 0) {
			displayText[len - 1] = '\0';  // ลบตัวอักษรตัวสุดท้าย
			DisplayTextBox();  // แสดงกล่องข้อความที่อัปเดตหลังจากลบ
		}
	}
}


// ฟังก์ชันหลักสำหรับการทดสอบแป้นคีย์บอร์ดตัวอักษร
void Touch_TestLetterEntry() {
	uint16_t x_touch, y_touch;
	uint8_t isTouch;

	DrawLetterButtons();  // วาดปุ่มตัวอักษร A-Z
	DisplayTextBox();     // แสดงกล่องข้อความ

	while (1) {
		Touch_GetXYtouch(&x_touch, &y_touch, &isTouch);
		if (isTouch) {
			CheckLetterButtonPress(x_touch, y_touch);  // ตรวจจับการกดปุ่มตัวอักษร
		}
		HAL_Delay(100);
	}
}
